mdl 1.3;

import ::anno::*;
import ::math::*;

export float linear_to_srgb( uniform float v ) uniform {
  if (v <= 0.0031308)
    return v * 12.92;
  else
    return 1.055 * math::pow(v, 1.0 / 2.4) - 0.055;
}

export color linear_to_srgb( uniform float r, uniform float g, uniform float b ) uniform {
  return color( linear_to_srgb(r), linear_to_srgb(g), linear_to_srgb(b) );
}

export float srgb_to_linear( uniform float v ) uniform {
  if (v <= 0.04045)
      return v / 12.92;
  else
      return math::pow((v + 0.055) / 1.055, 2.4);
}

export color srgb_to_linear( uniform float r, uniform float g, uniform float b ) uniform {
  return color( srgb_to_linear(r), srgb_to_linear(g), srgb_to_linear(b) );
}

export float adjust_ior_with_specular_level( uniform float max_ior, varying float specular_level, uniform float level_offset = 0.5 ) varying
[[
    anno::description("Scales reflectance linearly between IOR 1.0 and max_ior according to specular_level (works above and below 1.0 max)")
]]
{
  float ior_change = math::sqrt(specular_level/level_offset) * (1.f-max_ior)/(1.f+max_ior);  // square and square root cancel the second half without a +/-
  return (1.f - ior_change)/(1.f + ior_change);
}

export float3 scale_normal( varying float3 base_normal, uniform float scale) varying
[[
    anno::description("Scales normal while preserving detail")
]]
{
    // TO DO: Update with hybrid model, scaling by angle when scale<1
    if (scale < 0.0001) {
      return base_normal;
    }
   	return math::normalize( float3(base_normal.x, base_normal.y, base_normal.z / scale) );
}